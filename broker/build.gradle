apply plugin: "org.springframework.boot"
apply plugin: "io.spring.dependency-management"

bootJar.enabled = false
jar.enabled = true

// For spring.dependency-management plugin: checks that the versions are the ones defined here
//TODO Not sure if we need this after the dependency management implemented for gradle
ext['tomcat.version'] = versions.tomcat
ext['flyway.version'] = versions.flyway
ext['groovy.version'] = versions.groovy

processResources {
    filesMatching(["*.properties", "**/application-info.yml"]) {
        expand(project.properties)
    }
}

configurations {
    all*.exclude group: 'org.slf4j', module: 'log4j-over-slf4j'
    all*.exclude group: 'ch.qos.logback', module: 'logback-classic'
}

dependencies {
    compile project(':model')
    compile project(':client')
    compile project(':broker:core')

    compile libs.spring_boot_starter_log4j2
    compile libs.spring_boot_starter_autoconfigure
    compile libs.spring_boot_starter_data_jpa
    compile libs.spring_boot_starter_jdbc
    compile libs.spring_boot_starter_security
    compile libs.spring_boot_starter_actuator
    compile libs.spring_boot_starter_devtools
    compile libs.spring_boot_starter_webflux

    compile libs.spring_cloud_open_service_broker
    compile libs.spring_cloud_starter_open_service_broker_webmvc
    compile libs.spring_cloud_starter_config
    compile libs.spring_cloud_cloudfoundry_connector

    compile libs.spring_context_support
    compile libs.spring_security_config
    compile libs.spring_security_oauth2_client

    compile libs.groovy
    compile libs.groovy_dateutil

    compile libs.guava
    compile libs.gson
    compile libs.quartz
    compile libs.flyway

    compile libs.slf4j
    compile libs.log4j
    compile libs.log4j_to_slf4j
    compile libs.tomcat_juli

    compile libs.influxdb_java

    runtime libs.mysql_connector_java
    runtime libs.javax_el_api
    runtime libs.javax_el

    if (project.hasProperty('tomcat')) {
        // Used for production environment
        System.out.println('tomcat')
        providedRuntime libs.spring_boot_starter_tomcat
    } else {
        System.out.println('standalone')
        runtime libs.spring_boot_starter_tomcat
    }

    testCompile libs.groovy
    testCompile libs.groovy_test
    testCompile libs.junit
    testCompile libs.spock
    testCompile libs.spock_spring
    testCompile libs.cglib
    testCompile libs.groovy_test
    testCompile libs.spring_boot_starter_test
}

// Add integration/functional test source sets
sourceSets {
    integrationTest { sourceSet ->
        ["java", "groovy", "scala", "resources"].each {
            if (!sourceSet.hasProperty(it)) return
            sourceSet."$it".srcDir file("src/integration-test/${it}")
        }
    }
    functionalTest { sourceSet ->
        ["java", "groovy", "scala", "resources"].each {
            if (!sourceSet.hasProperty(it)) return
            sourceSet."$it".srcDir file("src/functional-test/${it}")
        }
    }
}

// Setup dependencies for integration testing
dependencies {
    integrationTestCompile sourceSets.main.output
    integrationTestCompile sourceSets.test.output
    integrationTestCompile configurations.testCompile
    integrationTestRuntime configurations.testRuntime

    functionalTestCompile sourceSets.main.output
    functionalTestCompile sourceSets.test.output
    functionalTestCompile sourceSets.integrationTest.output
    functionalTestCompile configurations.testCompile
    functionalTestRuntime configurations.testRuntime
}

// Define integration test task
task integrationTest(type: Test) {
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
}

// Define function test task
task functionalTest(type: Test) {
    testClassesDirs = sourceSets.functionalTest.output.classesDirs
    classpath = sourceSets.functionalTest.runtimeClasspath
}

task buildCloudFoundryManifest() {
    String fileContent = new File("$projectDir/../manifest-template.yml").text
    fileContent = fileContent.replaceAll("%releasePackage%", "broker-$version")
    project.file("$projectDir/build/libs").mkdirs()
    new File("$projectDir/build/libs/manifest.yml").text = fileContent
}

configurations {
    testArtifacts.extendsFrom testRuntime
    testCompile.exclude group: "ch.qos.logback"
}

task testJar(type: Jar) {
    classifier "test"
    from sourceSets.integrationTest.output + sourceSets.functionalTest.output
}

artifacts {
    testArtifacts testJar
}

// Make sure 'check' task calls integration test
check.dependsOn integrationTest
integrationTest.mustRunAfter test

// Make sure 'check' task calls functional test
check.dependsOn functionalTest
functionalTest.mustRunAfter integrationTest

test {
    testLogging.showStandardStreams = true
    testLogging.exceptionFormat = 'full'
}