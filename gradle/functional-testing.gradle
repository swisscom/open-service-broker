/*
 * Copyright (c) 2019 Swisscom (Switzerland) Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use
 * this file except in compliance with the License. You may obtain a copy of the
 * License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

// Add integration/functional test source sets
sourceSets {
    integrationTest { sourceSet ->
        ["java", "kotlin", "groovy", "scala", "resources"].each {
            if (!sourceSet.hasProperty(it)) return
            sourceSet."$it".srcDir file("src/integration-test/${it}")
        }
    }
    functionalTest { sourceSet ->
        ["java", "kotlin", "groovy", "scala", "resources"].each {
            if (!sourceSet.hasProperty(it)) return
            sourceSet."$it".srcDir file("src/functional-test/${it}")
        }
    }
}

dependencies {
    integrationTestCompile sourceSets.main.output
    integrationTestCompile sourceSets.test.output
    integrationTestCompile configurations.testCompile
    integrationTestRuntime configurations.testRuntime

    functionalTestCompile sourceSets.main.output
    functionalTestCompile sourceSets.test.output
    functionalTestCompile sourceSets.integrationTest.output
    functionalTestCompile configurations.testCompile
    functionalTestRuntime configurations.testRuntime
}

// Define integration test task
task integrationTest(type: Test) {
    systemProperties System.getProperties()
    testClassesDirs = sourceSets.integrationTest.output
    classpath = sourceSets.integrationTest.runtimeClasspath
}

// Define function test task
task functionalTest(type: Test) {
    systemProperties System.getProperties()
    testClassesDirs = sourceSets.functionalTest.output
    classpath = sourceSets.functionalTest.runtimeClasspath
}

// Make sure 'check' task calls integration test
check.dependsOn integrationTest
integrationTest.mustRunAfter test

// Make sure 'check' task calls functional test
check.dependsOn functionalTest
functionalTest.mustRunAfter integrationTest

tasks.withType(Test) {
    testLogging {
        // set options for log level LIFECYCLE
        events TestLogEvent.FAILED,
                TestLogEvent.PASSED,
                TestLogEvent.SKIPPED,
                TestLogEvent.STANDARD_OUT
        exceptionFormat TestExceptionFormat.FULL
        showExceptions false
        showCauses true
        showStackTraces true

        // set options for log level DEBUG and INFO
        debug {
            events TestLogEvent.STARTED,
                    TestLogEvent.FAILED,
                    TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED,
                    TestLogEvent.STANDARD_ERROR,
                    TestLogEvent.STANDARD_OUT
            exceptionFormat TestExceptionFormat.FULL
        }
        info.events = debug.events
        info.exceptionFormat = debug.exceptionFormat

        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                def startItem = '[', endItem = ']'
                def repeatLength = startItem.length() + output.length() + endItem.length()
                println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
            }
        }
    }
}
